
1
00:00:00,110 --> 00:00:08,620
And it's gonna be a bit more technical than the first one, but it's not gonna be kind of scary technical.

2
00:00:09,570 --> 00:00:34,170
It's just going to mention a few technical things, I'm afraid I tried to make the kind of talks separate so that somebody coming in now could follow my speech, so it might cover a bit of the same ground covered in the previous ones, probably not too much, though.

3
00:00:40,490 --> 00:00:44,260
Again, I have a content slide, uh.

4
00:00:46,360 --> 00:01:08,400
I'll start off by mentioning a few design issues in developing the Linux kernel, then I'll mentioned the basic design behind the system, ah, how development actually happens a bit, then I'll take the three parts.

5
00:01:08,400 --> 00:01:15,620
I consider ?mine the process management, the file system code and the memory management code.

6
00:01:15,620 --> 00:01:47,160
I'll look at them a bit uh, they are actually not even the largest parts of the kernel, but they are kind of the basic blocks, and the ones I keep most under wraps do most of the things myself, then finally, I'll take a look at some of the working progress right now in the kernel coding part of the kernel.

7
00:01:55,230 --> 00:01:56,760
Okay design issues.

8
00:01:56,760 --> 00:01:59,570
The one first one is keep it simple.

9
00:02:00,150 --> 00:02:06,000
Everybody who has written a kernel knows writing Kernels is not very simple.

10
00:02:06,000 --> 00:02:15,390
There are lots of complications that don't necessarily exist in other programs, so if you want to get something that works.

11
00:02:15,390 --> 00:02:41,630
You want to keep it very simple and to do that, you usually have to kind of leave out the bits that look too complicated or or features that might be nice, but that are require too much complexity of the rest of the system.

12
00:02:44,110 --> 00:02:51,260
On the other hand, I did want to have a very compatible system because while I enjoy writing kernels.

13
00:02:51,260 --> 00:03:14,470
I don't enjoy writing editors and compilers and shells, and so on, so I wanted to have this part of the UNIX system portable directly with minimum amount of work so that I could go on writing the actual kernel. Linux tries very actively to be as compatible as possible.

14
00:03:14,790 --> 00:03:16,870
Even if that does mean some problems.

15
00:03:17,270 --> 00:03:23,690
Then because of brain damage in the original design and so on, they are actually pretty few of them.

16
00:03:23,690 --> 00:03:28,180
There are brain damages in some added features, but that's okay.

17
00:03:28,930 --> 00:03:30,580
We can just skip the features.

18
00:03:30,580 --> 00:03:35,040
We don't think it is are worth it. Also

19
00:03:35,040 --> 00:03:36,960
I'm a performance freak.

20
00:03:37,710 --> 00:03:53,730
I actually compile the kernel into assembly code every once in a while, just to look at what the compiler says, and if I don't like their output, I've changed the C code to compile better.

21
00:03:53,730 --> 00:04:18,660
This may result in kind of weird code because GCC is not optimized for the kind of architecture Linux is running on, especially the lack of registers lead to kind of bad code, so if you actually look at the Linux code, you'll see that I sometimes do things a bit.

22
00:04:18,660 --> 00:04:23,120
Non intuitively, it might be due to my weird coding standards.

23
00:04:23,120 --> 00:04:28,850
But it might also be due to the fact that it results in better code when compiled uh.

24
00:04:29,740 --> 00:04:38,329
Also the thing about maximizing performance means that I don't want to penalize hardware good.

25
00:04:38,329 --> 00:04:44,820
So if if you have lots of memory, I want Linux to take advantage advantage.

26
00:04:44,820 --> 00:04:51,930
I mean, this may sometimes mean that Linux doesn't run quite as fast on small machines.

27
00:04:53,390 --> 00:05:01,630
Also, if you do have a mascot processor as I do.

28
00:05:01,630 --> 00:05:16,200
I want Linux to take full advantage of it, so unlike unlike some other systems which use software floating point by default, Linux uses hardware floating point by default, and then let's the emulator.

29
00:05:16,200 --> 00:05:17,130
Take care of it.

30
00:05:17,790 --> 00:05:43,350
I dislike intensely systems like well some SPARC stations, which where the compiler by default starts using the soft floating point when it knows that the hardware can't support it, supports things like square roots and so on, and then when you move over the binary to a better machine, that does support square roots.

31
00:05:43,350 --> 00:05:52,350
The code doesn't run as fast as it should, so I like to get the most out of the machine.

32
00:05:52,350 --> 00:06:08,370
If it can do it, and if it can't, well tough luck Linux still gets pretty good performance even on a low end machine, so I try to also keep it.

33
00:06:09,070 --> 00:06:12,900
It's usable, even even when you don't have a mascot processor.

34
00:06:12,900 --> 00:06:18,070
Just to make something like that, also, the final thing is.

35
00:06:18,070 --> 00:06:36,620
I don't want to add a feature which may turn out to be hard to keep up, so I don't want to add limits or things that could limit future expansion like the 640k limiting DOS.

36
00:06:36,620 --> 00:06:38,480
I tried to avoid those.

37
00:06:39,490 --> 00:06:45,990
This means that some features people have asked for and that could be easy to implement.

38
00:06:47,700 --> 00:06:49,850
Like, for example.

39
00:06:49,850 --> 00:07:11,730
People have asked for for a PC direct access to screen memory in order to to be able to write cursors, type programs with menus and so on, easier, easily, and I don't actually want to support that kind of thing because it then doesn't port to different machines at all.

40
00:07:13,000 --> 00:07:16,160
So I tried to avoid things that lock us to some design.

41
00:07:19,570 --> 00:07:32,690
Well, this has resulted in in the kernel is a) that keep it simple design resulted in the monolithic kernel.

42
00:07:34,560 --> 00:07:43,220
This is something of a debate in the ya operating system community.

43
00:07:44,500 --> 00:07:51,210
The microkernel people think that microkernel are easier to write, and I think I disagree strongly.

44
00:07:51,590 --> 00:08:22,610
I think micro kernels are hard at right, especially if you don't have anything to start up from. Monolithic kernel may have some problems in keeping up the code and upgrading and so on, but it also makes it much easier to actually change the internals of the kernel completely without having to change several different subsistence, which may happen in microkernel Uh.

45
00:08:22,610 --> 00:08:33,820
Unbiased, the first kernel I use from Minix which purported(传说) to be a microkernel and did it horribly badly.

46
00:08:34,900 --> 00:08:51,850
So instead of having modularity due due to the basic design of the kernel like a microkernel DOS, I've tried to make Linux reasonably modular so that there are separate some directories codes.

47
00:08:51,850 --> 00:09:18,480
Major pieces of the kernel, and so on. Also uh, when something looks like it could be ugly to implement, I'd rather skip it and trying to implement to make a kernel easier to program, especially because the two major problems in writing an operating systems.

48
00:09:18,930 --> 00:09:38,940
Maybe race conditions and deadlocks due to locking, so what I did and what the original UNIX did was make the kernel non preemptible(抢占) when a process runs in kernel mode, no other process will preempted unless the process yields control voluntarily.

49
00:09:41,330 --> 00:09:53,910
This leads to to a code that doesn't need any any locking on internal data structures because you know you're not going to going to be interrupted by some other process.

50
00:09:54,750 --> 00:10:16,940
You still have races when it comes to to actually interrupt handling, and then you have races when you try to access use the code data, which might be swept out or when you try to do some I/O, but those races at least know about so much, they're more dependable.

51
00:10:16,940 --> 00:10:40,000
You know when when an interupt can change your data structures and you also know when you actually access user code, the basic design, which is one of the problems right now, is that the whole kernel is kind of non portable.

52
00:10:40,600 --> 00:10:52,230
It's less so than it was at one point, but still it's about 176000 lines right now, which is it's not the smallest UNIX kernel around.

53
00:10:52,230 --> 00:10:54,340
But it's still pretty small.

54
00:10:54,340 --> 00:11:05,640
It compiles in about 10 minutes if you have reasonable machine and of that, almost exactly half is devices' drivers.

55
00:11:06,130 --> 00:11:20,130
It's actually within a line or two right now, which is just because the PC hardware has so many different devices, so it's kind of naturally machine specific the code.

56
00:11:20,610 --> 00:11:29,180
But also some of the design decisions I made earlier on were kind of bad in making it portable.

57
00:11:29,180 --> 00:11:36,070
So I expect to have some problems importing the memory management code to a 64 bit machine and so on.

58
00:11:36,910 --> 00:11:42,040
On the other hand, the memory management code right now is less than 2000 lines.

59
00:11:42,040 --> 00:11:46,720
If I remember correctly, so porting that isn't too bad.

60
00:11:59,770 --> 00:12:22,440
The development framework is is kind of set out by the fact that the whole development of Linux is completely open, and I put out my latest version of the kernel about every two days or so, uh, the latest version right now is 1.1.12.

61
00:12:22,440 --> 00:12:49,530
Which I put out the day before I left for my the alpha versions like this one, which I put out, may not even compile, and in fact, 1.1.12 doesn't link, unless you add a line to a Makefile, but this does mean that people can test out my version.

62
00:12:49,530 --> 00:13:10,660
My latest version and new changes against that and interactively kind of see all the changes down to the kernel in the last few days, ah to kind of control the problems that arise when many different persons work on the same sources.

63
00:13:10,660 --> 00:13:19,310
There's a coding style standard, which is essentially that all code has to be ANSI-C.

64
00:13:20,010 --> 00:13:24,960
And the bracing style is the one through bracing style i.e

65
00:13:24,960 --> 00:13:29,470
The one used in we are already Kernighan & Ritchie book.

66
00:13:29,780 --> 00:13:42,870
I'm not religious about this, so when I get a driver, which I know I can't keep up, I don't change the actual formatting, but the kernel.

67
00:13:42,870 --> 00:13:48,350
For example, is always compiled with all warnings enabled, and if I get a warning.

68
00:13:48,350 --> 00:14:07,460
I know something is wrong, so there's kind of type checking and so on, which helps avoid some of the problems you don't otherwise have with several persons working on the same sources, also due to the fact that major parts are in different subdirectories.

69
00:14:07,460 --> 00:14:14,260
I can, for example, concentrate on the ones I consider mine.

70
00:14:14,260 --> 00:14:23,550
i.e. the kernel, the FS and MM memory management subdirectory and people who write device driver.

71
00:14:23,550 --> 00:14:32,540
For example, there's a separate driver's subdirectory, which is partitioned into character drivers, loop drivers and SCSI and SAN.

72
00:14:32,540 --> 00:14:39,750
So so people can actually give me a whole packet, which contains a new driver.

73
00:14:39,750 --> 00:14:47,400
And I don't even need to know about the internals of it because it just fits in in its specific place.

74
00:14:50,640 --> 00:15:02,790
Uh, the other thing, the main benefit of actually having this kind of open development is fast feedback from developers you get has feedback from users too.

75
00:15:02,790 --> 00:15:20,320
But it also means that that when a developer sends me some patch to his driver as similar, I can put it in the same day, maybe make a new version the next day, and then the developer knows that's okay.

76
00:15:20,320 --> 00:15:44,380
Linux predicting into his latest kernel now I need I can forget about these old problems and concentrate on the new, which sadly they always are in once so far, what this means in practice is that I'm at kind of the top of the hierarchy of developers, and under me.

77
00:15:44,380 --> 00:15:56,300
I have a few trusted kernel developers I trust I have or there is one person who mainly handles the networking side of Linux.

78
00:15:56,300 --> 00:16:23,080
There's one person who mainly handles SCSI drivers, one for every file system except for the Minix FS, which I brought myself and so on, so these are kind of trusted in their own areas, and under them, they may have a few more, which they trust to do minor patches to that part.

79
00:16:23,680 --> 00:16:48,160
And the patches then go from downwards up to me and then into the standard kernel uh, this is a core team like hierarchy used in XFree86 and so on, because outside intervention is is actually encouraged and appreciated.

80
00:16:48,160 --> 00:16:56,210
So so you don't have to be recognized developer to actually send me a patch, and I do get patches by honest.

81
00:16:57,460 --> 00:17:08,670
I do get patches that are kind of two lines of patches, which fixed a small problem by somebody I've never heard about before, and if it's obviously the correct patch.

82
00:17:08,670 --> 00:17:10,790
I use it, so it's not a problem.

83
00:17:10,790 --> 00:17:14,050
If you recognized developer.

84
00:17:18,860 --> 00:17:28,540
Okay, ah, I'll take up the process management part of the kernel.

85
00:17:28,540 --> 00:17:32,300
I don't know if process management is actually the right word.

86
00:17:32,300 --> 00:17:59,520
Maybe something like basic building blocks is the kernel sub directory of the Linux kernel and contains all the really low level details about the machine, except for the memory management and handles interrupts, exceptions and dma, and so on.

87
00:18:00,560 --> 00:18:08,740
So when a driver wants to use some interrupt, it asks the kernel, could I have this interrupt?

88
00:18:08,740 --> 00:18:13,840
Could you redirect me and then the kernel decides if some.

89
00:18:13,840 --> 00:18:27,250
Maybe some other driver already has that interact also, the the process management actually does contain process management, so it takes care of any system called requests.

90
00:18:27,250 --> 00:18:29,000
The process may do.

91
00:18:29,560 --> 00:18:43,680
It also takes care of of any process faults, so when a process tries to do something that's illegal like disabled interrupts, the kernel notices this and kills the processes.

92
00:18:45,530 --> 00:18:56,620
Uh, there's a separate file for handling the virtual 86 mild in the 366 processor, which is used by the DOS emulator

93
00:18:58,410 --> 00:19:19,390
and possibly in the future that windows similar, so there's also the Linux kernel by itself is uses the flat address space of the 386, so it actually has only a code and data segment, which covered the whole address based on the process.

94
00:19:19,970 --> 00:19:23,140
But the process can ask for segments.

95
00:19:23,550 --> 00:19:44,680
And the kernel will give it within reason up to 512 or something like that segments it could use if somebody really wants to use a segment to the architecture this year, again is used mainly for windows emulation, but.

96
00:19:50,220 --> 00:20:14,820
Okay, I'll actually give a programming example of of a kind of I don't know how different this is, because I never saw real UNIX source code before starting on Linux and after starting on Linux, I have actively tried to avoid it, plus it actually would take too much of my time.

97
00:20:14,820 --> 00:20:31,440
So I it hasn't been a problem avoiding it, but traditionally in operating systems, the actual action of going to sleep or scheduling a process is closely tied to the state

98
00:20:31,440 --> 00:20:34,790
the process is in which leads to some problems.

99
00:20:36,060 --> 00:21:01,620
You have a special call, which is please now I'd like to sleep on this special, this action variable or whatever, which leads to race conditions, because you usually have something like this, you have if some empty.

100
00:21:09,370 --> 00:21:13,710
Okay, this is just to give you an idea.

101
00:21:14,190 --> 00:21:21,740
You have code that says, if this buffer is empty, I want to sleep on it until it is filled again.

102
00:21:24,100 --> 00:21:32,440
Now this looks simple, but has the problem that between the test and the sleep.

103
00:21:32,990 --> 00:21:39,750
The buffer might actually get filled, then would sleep on something that will never happen to handle this.

104
00:21:39,750 --> 00:22:09,570
You have semi force and event counters and so on, but and I knew of this, but I actually decided on a completely different solution, which was to have separate process, state and scheduling primitives, so you have a process state which the process can set by itself here.

105
00:22:10,370 --> 00:22:17,670
The current process says that now I'm sleeping, but what it's actually is doing is it's lying to the kernel.

106
00:22:17,670 --> 00:22:28,080
It's not going to sleep at all because the scheduling is separate, then it tests for the event in the example.

107
00:22:28,080 --> 00:22:31,810
This would test if it's empty way.

108
00:22:31,810 --> 00:22:49,500
Sleep, what the this advice, care and remove weight care are doing is setting up the information to to tell whatever routine that fills the buffer, which process to wake.

109
00:22:50,690 --> 00:23:17,950
Now the race condition is completely gone because if an interrupt comes in here, the interact, so notice the event q and Wake up the change, the state of the current process and the schedule will do nothing at all, so now we won't sleep on a on something that never happens.

110
00:23:19,710 --> 00:23:27,000
I don't you may know, is this done in any other operating system like this, okay, no good enough.

111
00:23:30,100 --> 00:23:42,050
This is actually has the evident advantage that sleeping on several different events is a natural extension of this ah, which is not that easy.

112
00:23:42,050 --> 00:23:59,980
If you have a sleep call, if you had a sleep call, which goes to sleep, you can't put many of them after each other because the first one will go to sleep, so so this actually works very well with the select() semantics I mentioned order.

113
00:24:02,060 --> 00:24:03,920
I don't have to do it other different ways.

114
00:24:03,920 --> 00:24:05,100
This was just an example.

115
00:24:06,270 --> 00:24:06,910
Okay?

116
00:24:09,080 --> 00:24:16,620
The other major part I I my personal responsible for is the file system code.

117
00:24:18,250 --> 00:24:28,680
Which actually what it does is virtualizes the file system interface and doesn't know anything about the file system at all.

118
00:24:29,350 --> 00:24:44,520
Internally, it just looks at the requests the users mix the user mix, and then translates this into the appropriate tool internal virtual power system interface calls.

119
00:24:45,250 --> 00:24:59,040
Unlike at least BSD 4.3, which used a special Inode for a normal file and then a Vnode for a virtual file or NFS.

120
00:24:59,040 --> 00:25:03,990
For example, Linux doesn't have separate Inodes Vnodes.

121
00:25:03,990 --> 00:25:12,360
Linux just has Vnodes, and then, well, we call them Inodes because why not, they're the only thing we have.

122
00:25:13,290 --> 00:25:21,000
And then, uh, let's the lower level file system stuff handle anyway, they want to.

123
00:25:21,310 --> 00:25:24,120
I think 4.4 does it this way, too?

124
00:25:24,120 --> 00:25:41,870
I'm not sure what this allows is kind of the basic blocks for any file system are in the vfs layer, notably buffer cache handling some name.

125
00:25:41,870 --> 00:25:49,080
Look up the basic UNIX semantics for mounting a file system.

126
00:25:49,080 --> 00:26:02,390
So on, and then we have separate modules that actually implement each file system, and Linux has no, no native file system at all.

127
00:26:03,340 --> 00:26:05,510
All file systems are equal.

128
00:26:05,510 --> 00:26:07,310
It's kind of a communistic system.

129
00:26:07,310 --> 00:26:22,220
That's why the actual low level of file system components right now, there are 10 of them are the one we call native Linux, which is the second extended file system.

130
00:26:22,770 --> 00:26:51,080
Which allows long file names, big partitions, I think up to 4 terabytes and size file sizes of up to 2 gigabytes, then there's XFS, which is similar but slightly different and um, the Minix file system.

131
00:26:51,080 --> 00:26:58,550
Which is the original one, which is the same one as in the minix operating system.

132
00:26:58,550 --> 00:27:24,460
Which I used to copy files over and then System V file system, which can mount scenic, coherent and some other system 5 performance more non UNIX file system type is the ms-dos file system.

133
00:27:24,460 --> 00:27:33,910
If you do use ms-dos, you can just mount your MSDOS, partition or floppy or whatever, and it looks like a UNIX fast extended Linux.

134
00:27:34,760 --> 00:27:58,340
Of course, there are limitations like 8 characters, adult and three characters, and then you don't have any separate protection rights, they will start it up at mount time and are the same for the whole file system, so you also there is also OS/2 HPFS file system.

135
00:27:58,340 --> 00:28:00,350
This one is currently read.

136
00:28:00,350 --> 00:28:15,320
Only you can't write to the OS/2 partition, but you can read your files from it, and there is the CDROM ISO 9660 file system used for most theaters.

137
00:28:15,750 --> 00:28:21,140
It has ?Rockridge extensions, so you get long file names and symbolic things, and so on.

138
00:28:23,290 --> 00:28:24,980
There's a third file system.

139
00:28:24,980 --> 00:28:34,670
Somebody call it the most fun you can have with the file system, which is the virtual /proc file system.

140
00:28:35,180 --> 00:28:42,900
I got the idea from what I've read of Plan 9 and tried to get the best things of that.

141
00:28:43,750 --> 00:28:56,680
It turns out that System V release 4 also has a proc file system, but don't confuse the Linux proc file system and the System V versions because the System V version is totally brain dead and useless.

142
00:28:56,680 --> 00:29:15,950
The Linux the Linux profile system is actually extremely useful, and uh, we've made away with all the kernel memory hacking you needed to do for processes like ps and who and uptime and so on.

143
00:29:15,950 --> 00:29:23,740
They just read the virtual system, and if you don't have an uptime binary.

144
00:29:23,740 --> 00:29:32,400
What you can do is you just cut frock up time and you get the how long the system has been running in seconds.

145
00:29:33,270 --> 00:29:42,330
So on the actual uptime binary, then pretty face these two days hours minutes and how many users they're on and so on.

146
00:29:45,390 --> 00:29:53,030
The proc file system is, completely internal to the kernel.

147
00:29:53,030 --> 00:29:55,560
It doesn't exist physically at all.

148
00:29:56,470 --> 00:30:07,190
You just it just looks like a file system, other file system there's been talk about, and I have actually been implemented is a FTP file system.

149
00:30:07,770 --> 00:30:23,900
Which looks like a file system, but when you do get a file, it goes through the FTP protocol and gets it from some other site, this is possible done actually as a user level file system, but it's not in the default kernel.

150
00:30:24,270 --> 00:30:26,530
And I wouldn't trust it myself.

151
00:30:28,000 --> 00:30:28,020
The.

152
00:32:34,350 --> 00:32:39,990
Being stunned, if I understand correctly, okay.

153
00:32:39,990 --> 00:32:43,730
This is just you won't do much with that.

154
00:32:43,730 --> 00:32:50,920
It's a list of all the functions you need to implement in order to create the a file system.

155
00:32:51,720 --> 00:33:15,720
In fact, you don't need to implement them all, but they are divided into three levels file operations, Inode operations and super block operations uh, this allows you to do just a subset of the virtual file system code needed.

156
00:33:15,720 --> 00:33:24,107
For example, unnamed pipes which don't have any other semantics than the file operations.

157
00:33:24,107 --> 00:33:30,920
They they actually don't even have the the higher level VFS interfaces at all.

158
00:33:43,720 --> 00:33:48,450
The perhaps most interesting part of the Linux kernel is actually with the memory management.

159
00:33:50,070 --> 00:33:53,060
It's also one of the smallest parts.

160
00:33:53,060 --> 00:34:11,230
But as memories, such a fundamental resource in a UNIX operating system in any operating system, in fact, you want to make the fullest possible use of the memory you have in a machine, especially on a PC.

161
00:34:11,230 --> 00:34:17,410
Where you may have only 8 megabytes and Emacs takes up all of that

162
00:34:17,410 --> 00:34:45,660
so when you have, but the kernel wants memory for internal resources like a buffer cache and for internal data structures like the Inodes and file, the user processes once memory for for actual code and data, ah, well, I take took up to mention file buffering already.

163
00:34:46,190 --> 00:35:02,670
Also, there's shared memory, which then acts differently and then from use or normal use from memory and to maximize and optimize all this, I tried to a) minimize free memory.

164
00:35:02,670 --> 00:35:05,540
By definition, free memory is useless.

165
00:35:05,540 --> 00:35:07,920
You don't do anything with free memory

166
00:35:07,920 --> 00:35:33,420
So while some other operating systems try to keep something like 10 percent of the memory free for potential use, Linux actually tries to keep something like 100 kilobytes on a 60 megabyte machine, which is kind of panic memory if if some interrupt needs memory now, it has 100k to use.

167
00:35:34,430 --> 00:35:37,100
This is mostly for network device drivers.

168
00:35:37,100 --> 00:35:39,310
So when a packet comes in, it's gone.

169
00:35:40,230 --> 00:35:54,030
Ask for for this limited resource, uh, all other memories then used for either process memory or for buffers.

170
00:35:54,670 --> 00:36:07,420
So if the machine in this building is still up after this, you can go and look at it and type the free command, which so shows how much free memory you have.

171
00:36:08,580 --> 00:36:11,390
It had 2 megabytes of ram.

172
00:36:11,390 --> 00:36:46,360
When I installed Linux and it used 28 megabytes of, that's for buffer space to speed up if operations. Now, when it's running X and whatever the buffer space automatically shrinks and only probably something like 7 megabytes or so, I used for buffers, just minimizing free memory isn't good enough.

173
00:36:46,360 --> 00:36:50,650
You can minimize free memory by just using it up

174
00:36:50,650 --> 00:37:10,770
You can minimize free memory by starting up Emacs, so so to actually maximize the use of memory, you want to use memory efficiently, preferably in a way that you actually use the same page of physical memory several times.

175
00:37:10,770 --> 00:37:32,250
Yeah, so Linux not just shares memory by copy ?on write? between processes which have forked. It also shares memory with ah processes that share the same executable image or share the same shared library.

176
00:37:35,140 --> 00:37:48,140
Ah, it even shares memory with the buffer space, so the same physical page could contain the buffers for an executable.

177
00:37:48,140 --> 00:37:56,200
It could also be mapped into several different programs as actual code.

178
00:37:57,970 --> 00:38:17,830
And again, if you use the free command on the PC Linux PC here, you usually get something like 8 or 10 megabytes of shared memory, which doesn't mean that it's shared like System V style IPC shared memory.

179
00:38:17,830 --> 00:38:20,980
It just means the Linux notice, okay,

180
00:38:20,980 --> 00:38:27,750
All these processes and this file system buffer cache are actually having the same data.

181
00:38:27,750 --> 00:38:32,177
So we just use one physical page for it

182
00:38:32,177 --> 00:38:49,690
On my home machine this means that I have 16 megabytes of physical ram and actually the kernel map seen about 24 megabytes of virtual memory.

183
00:38:49,690 --> 00:39:05,340
At the same time by using that's 50 percent larger than than you actually having the machine by just reusing the pages as much as possible.

184
00:39:09,960 --> 00:39:18,160
Okay. again getting close to the frozen to the end.

185
00:39:20,330 --> 00:39:27,990
And I'll just mention a few things I'm working on, and some other developers are working on.

186
00:39:29,750 --> 00:39:32,300
We're working on kernel threads.

187
00:39:35,780 --> 00:39:58,140
I'm not actually sure if it's a good idea because some timings have indicated that if you can thread in user space, it's usually much faster to do task switching and so on, so for some applications, you don't actually want kernel threads because kernel threads then have to take, they have to be so generally,

188
00:39:58,140 --> 00:40:02,130
you automatically have to save more registers and so on.

189
00:40:03,190 --> 00:40:12,750
On the other hand, kernel threads are useful for lots of things so we're still going to implement the [inaudible] because it's an interesting idea.

190
00:40:14,180 --> 00:40:20,228
What this actually means is that we're separating that process structure.

191
00:40:20,228 --> 00:40:32,510
Which has been one large structure into separate file system, memory management and and and register task parts.

192
00:40:32,510 --> 00:40:52,347
Which allows different threads to share the same memory management or maybe have different virtual memory, but share the same open files or share the same root Inode so on.

193
00:40:52,347 --> 00:41:10,750
What's also being worked on and is actually in 1.1.12 kernel is an extended memory management, which allows better use of physical memory.

194
00:41:10,750 --> 00:41:20,620
The earlier earlier Linux kernels had the problem that all memory management was done on a page by page basis and all three pages

195
00:41:20,620 --> 00:41:32,770
where essentially on one long link, at least, which made it very hard to allocate physical contiguous(邻近的) memory of more than 4 kilobytes.

196
00:41:32,770 --> 00:41:36,340
Which is the page system that 386 processors.

197
00:41:36,340 --> 00:41:44,710
So for most applications, this doesn't matter, because physical memory uh.

198
00:41:44,710 --> 00:41:57,100
You can always map it in contiguousness several pages for user space applications, for example.

199
00:41:57,100 --> 00:42:22,260
But DMA and some other applications actually want the physical memory to be contiguous, so we wanted to allow a possibility of allocating larger chunks currently 128 kilobytes, which is the DMA limit on the PC at one time physically.

200
00:42:23,940 --> 00:42:32,130
Also, what I'm looking into, but haven't even started on yet is is optimizing the file system.

201
00:42:32,130 --> 00:42:50,380
It's currently works well and is pretty efficient, but at least the BSD crowd seemed to imply that file name ?cache might improve performance noticeably.

202
00:42:50,380 --> 00:42:54,070
Uh, that's one thing I look into.

203
00:42:55,480 --> 00:43:09,540
It shouldn't be too bad, but I also would like to make it's general enough that you could actually use it for things like NFS, which requires that you have time ?out and so on.

204
00:43:12,180 --> 00:43:19,920
Also just the file system cache in Linux is quite advanced.

205
00:43:19,920 --> 00:43:26,490
And in that it grows and shrinks dynamically and can share pages with user pages.

206
00:43:26,490 --> 00:43:29,720
But we're still looking into improving it further.

207
00:43:30,980 --> 00:43:58,907
Uh, it's kind of awkward because it uses the original UNIX way of indexing file system buffers by the device and the buffer number they are in, while it would be more efficient for the actual file system to index them by the Inode you know they are associated with and

208
00:43:58,907 --> 00:44:05,704
where in that file they are, so we're looking into changing that

209
00:44:05,704 --> 00:44:16,790
Also, what's older there to some extent, is loading kernel modules at runtime, so you could load a new driver.

210
00:44:16,790 --> 00:44:30,070
This is already used for the floppy tape driver, which isn't part of the standard kernel, but you just get a separate module compiled and linked it in.

211
00:44:30,940 --> 00:44:38,180
We're trying to make this more general, so eventually all kernel drivers will be loadable.

212
00:44:39,090 --> 00:44:50,550
So you could do a kernel, which unloads the drivers as it notices that the device isn't there and so on.

213
00:44:52,770 --> 00:44:59,170
Also, as was mentioned in the previous talk, we're porting it to different architectures.

214
00:45:00,430 --> 00:45:04,400
The 68k port did show some problems.

215
00:45:06,260 --> 00:45:31,620
On the other hand, it didn't turn out to be too bad, but the 68k is actually pretty close to the 386, in the bits, a 32-bits machine and has very similar memory management pointing to other architectures will probably show a lot of other problems in the Linux kernel in this area.

216
00:45:34,700 --> 00:45:38,030
That's it.  I'm afraid, and thank you for me.

217
00:45:47,390 --> 00:45:48,520
Are there any questions.

218
00:45:48,520 --> 00:45:53,510
Yes, John West, Digital Systems Consulting, yeah, could you speak up.

219
00:45:53,510 --> 00:46:01,684
John West, Digital Systems Consulting are there any plans for a compressed file system ?

220
00:46:01,684 --> 00:46:11,670
There are patches available for a compressed file system, I've heard some horror stories of it.

221
00:46:11,670 --> 00:46:21,670
And frankly, my personal opinion is that it doesn't pay others who have smaller disks, seem to disagree.

222
00:46:22,900 --> 00:46:32,491
Uh, we'll see, uh, I don't like the idea because it makes demand loading kind of hard

223
00:46:32,491 --> 00:46:39,156
That's an issue you can resolve them, but it has problems, okay

224
00:46:39,156 --> 00:46:49,830
J. P. Versus of University of Alaska, I was wondering if anyone's working on the Andrew File System for Linux.

225
00:46:49,830 --> 00:46:52,910
I don't know if I can talk about that.

226
00:46:54,160 --> 00:47:08,870
Actually, Andrew File System is proprietary, but we are working on extending the modules interface enough, but it could be used as a loadable module.

227
00:47:10,180 --> 00:47:20,020
I'm not certain I like the idea to learn about linking in preparatory stuff like Andrew File System to Linux without having access to the source code.

228
00:47:20,710 --> 00:47:31,860
But I also know that it would be so useful for MIT people that I'll probably allow it anyway, ah, from what I heard.

229
00:47:31,860 --> 00:47:48,980
The Andrew File System is already ported and the person working on it who has been an active Linux you so far at least two years, is now looking into the loadable interfaces, and he's optimistic about it.

230
00:47:48,980 --> 00:47:53,430
They're using it internally at MIT in at least some machines.

231
00:47:53,430 --> 00:47:56,122
As far as I know, okay

232
00:47:56,122 --> 00:48:06,650
Reese Political, Wall Gang Group, given that your first language is different than my first language.

233
00:48:07,540 --> 00:48:18,700
Having not seen, the sources are the comments and the variable names, and such in English or yeah, the language, yeah, they are always in English.

234
00:48:18,700 --> 00:48:34,800
I actually when I code, I think in English, and while my pronunciation may be kind of weird, I actually read most of the stuff I read is in English, so I think fluently in English, but I just talked it funny.

235
00:48:35,800 --> 00:48:44,620
Okay, John West, Digital Systems Consulting, is there a is there an implementation of DCE for Linux.

236
00:48:45,380 --> 00:48:47,400
Or do you know of any underdevelopment.

237
00:48:47,400 --> 00:48:51,140
I have no idea at all. [inaudible]

238
00:48:56,700 --> 00:48:59,290
Okay, it's proprietary probably.

239
00:49:04,880 --> 00:49:06,890
Okay, please.

240
00:49:06,890 --> 00:49:11,530
10 minutes, some more questions, and we can skip otherwise I make him tap dance.

241
00:49:15,200 --> 00:49:32,490
We'll draw, just wait, are you nervous, do you feel lucky, what's your name, I'll pull your card, oh, oh, you mean in drawing, okay, what do you want to draw, or do you want to draw now, she'll take a vote.

242
00:49:32,490 --> 00:49:43,670
How do you people want to him tap dances, okay, good that looked like a majority of you know, it was 3/4.

243
00:49:43,670 --> 00:49:56,090
No way what's that the three quarters, okay, we just want to hold this bag, check that I don't cheat ya, well, care.

244
00:50:01,280 --> 00:50:04,045
Who was your first?

245
00:50:04,045 --> 00:50:15,935
Robert Simon of principal engineer of Net Access products division, has already left. OK.

246
00:50:15,935 --> 00:50:29,900
next, who cares about him anyway. I guess I shouldn't give him all that pop Mary B. Koplinsky.

247
00:50:31,020 --> 00:50:35,400
Sorry about the name, I probably mispronounce it totally

248
00:50:42,770 --> 00:50:43,360
Congrats.

249
00:50:53,260 --> 00:50:53,270
Uh.

250
00:51:00,090 --> 00:51:09,680
And Wayne Shirley, engineering specialists from Monsanto. okay.

251
00:51:16,640 --> 00:51:17,450
Congratulations to you.

252
00:51:23,570 --> 00:51:23,750
Thank you.

253
00:51:25,110 --> 00:51:35,700
Okay, okay, now you're ready to see him tap dance a few more questions, and we can skip the cats dancing.

254
00:51:37,610 --> 00:51:55,540
I'd see the tap dancing or stripping, so okay, you promise I could wear a bag of my what's up, you promise I could wear a hat on bag on my head if I ?straight, that's right, we did promise that okay, to protect your dignity

255
00:51:55,540 --> 00:51:56,360
Here's a question.

256
00:51:57,650 --> 00:52:05,130
I've heard discussion, various mailing lists in the news groups about a Kerberos implementation.

257
00:52:05,130 --> 00:52:07,040
Do you know anything about it?

258
00:52:07,040 --> 00:52:24,610
What state it is in, I assume Kerberos shouldn't be any problem except and exporting it outside the US due to stupid regulations uh, it's not stupid, interesting.

259
00:52:24,610 --> 00:52:29,920
okay, I don't see that it should be a problem.

260
00:52:29,920 --> 00:52:36,040
I haven't [..] into it because I'm the trusting kind of guy who doesn't care what people do it to my machine.

261
00:52:39,450 --> 00:52:40,130
Okay, that's it.

262
00:52:42,950 --> 00:52:43,150
No one.

263
00:52:53,070 --> 00:52:55,810
The phone number, I'm going to the trade show.

264
00:53:15,960 --> 00:53:22,437
I speak Swedish as my mother's tougue and one of those my parents were born in Finland.

265
00:53:22,437 --> 00:53:32,050
I was born in Los Angeles, but I've learned something about you are connected on the Sunday talk instead of why I'll just.

266
00:54:04,870 --> 00:54:07,575
Well, I saw you coming up the elevator.

267
00:54:07,575 --> 00:54:09,542
Best play, the first that came in.

268
00:54:09,542 --> 00:54:11,160
I saw Linus, I could.

269
00:54:12,430 --> 00:54:18,850
I don't want to turn around. I spent the last three weeks on MIT server.

270
00:54:21,470 --> 00:54:24,410
I didn't know about the distributions

271
00:54:27,670 --> 00:54:30,120
I don't actually know which is easier.

272
00:54:30,120 --> 00:54:52,460
I've used the sunset because it seems to be at the larger one way I got some good help from some other people here who told me that okay, okay. how many files can be open to the just from this one on a purpose of spaces.

273
00:55:46,690 --> 00:55:47,870
Okay, there's some.

274
00:56:21,890 --> 00:56:23,390
[inaudible]
